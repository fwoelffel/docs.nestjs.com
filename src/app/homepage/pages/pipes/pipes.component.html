<div class="content">
   <h3>Pipes</h3>
   <p>
      Pipe is a class with <code>@Pipe()</code> decorator.
      The pipe should implements the <code>PipeTransform</code> interface.
   </p>
   <figure><img src="/assets/Pipe_1.png" /></figure>
   <p>
    A pipe <strong>transforms</strong> the input data to the desired output.
    Also, it could overtake the <strong>validation</strong> responsibility, since it's possible to throw an exception when the data isn't correct.
   </p>
   <blockquote>
    <strong>Hint</strong> The pipe runs inside the exceptions zone. It means that throwed exceptions are handled by core exceptions handler and <a routerLink="/exception-filters">exceptions filters</a> applied to the current context.
   </blockquote>
   <h4>Built-in pipes</h4>
   <p>
      Nest comes with two pipes available out-of-the-box, <code>ValidationPipe</code> and <code>ParseIntPipe</code>. They're exported from the <code>@nestjs/common</code> package. To better understand how do they work, we're gonna built them from scratch here.
   </p>
   <h4>What does it look like?</h4>
   <p>
     Let's start from the <code>ValidationPipe</code>. Now it only takes and returns the same value.
   </p>
   <span class="filename">validation.pipe.ts</span>
   <pre><code class="language-typescript">{{ validationPipe }}</code></pre>
   <blockquote>
      <strong>Notice</strong> The <code>ValidationPipe</code> works only with <strong>TypeScript</strong>. If you are working only with plain JavaScript, I'd recommend using a <a href="https://github.com/hapijs/joi" target="blank">Joi</a> library.
    </blockquote>
   <p>
     Every pipe has to provide the <code>transform()</code> method. This method takes two arguments:
   </p>
   <ul>
      <li><code>value</code></li>
      <li><code>metadata</code></li>
    </ul>
    <p>
      The <code>value</code> is a currently processed parameter, while <code>metadata</code> is its metadata.
      The metadata object holds few properties:
    </p>
    <pre><code class="language-typescript">{{ argumentMetadata }}</code></pre>
    <p>
      These properties describe the parameter.
    </p>
    <table>
      <tr>
        <td><code>type</code></td>
        <td>Tells us whether the property is a body <code>@Body()</code>, query <code>@Query()</code>, param <code>@Param()</code>, or custom parameter (read more <a routerLink="/custom-decorators">here</a>).</td>
      </tr>
      <tr>
        <td><code>metatype</code></td>
        <td>
          The metatype of the property, for example <code>String</code>. It's <code>undefined</code> if you would omit the type declaration in the function signature.
        </td>
      </tr>
      <tr>
        <td><code>data</code></td>
        <td>The string passed to the decorator, for example <code>@Body('string')</code>. It's <code>undefined</code> if you would left the brackets empty.</td>
      </tr>
    </table>
    <blockquote>
      <strong>Notice</strong> TypeScript interfaces dissapear during the transpilation, so if you'd use interface instead of class, the <code>metatype</code> value will be <code>Object</code>.
   </blockquote>
    <h4>How does it work?</h4>
    <p>
      Let's focus on the <code>create()</code> method of the <code>CatsController</code>:
    </p>
    <span class="filename">cats.controler.ts</span>
    <pre><code class="language-typescript">{{ createCatsController }}</code></pre>
    <p>
      There's a <code>CreateCatDto</code> body parameter.
    </p>
    <span class="filename">create-cat.dto.ts</span>
    <pre><code class="language-typescript">{{ createCatDto }}</code></pre>
    <p>
      This object always has to be correct, thus we have to validate these three members.
      We could do this inside the route handler method, but we'd break the <strong>single responsibility rule</strong> (SRP).
      The second idea is to create <strong>validator class</strong> and delegate the task there, but we'll have to use this validator every time at the beginning of the method.
      So what about the validation middleware? It's a good idea, but it's not possible to create a <strong>generic middleware</strong>, which could be used across entire application.
    </p>
    <p>
      That's the first use-case, when you should consider to use a <strong>Pipe</strong>.
    </p>
    <h4>Class validator</h4>
    <h5>This section applies only to TypeScript.</h5>
    <p>
      Nest works well with the <a href="https://github.com/pleerock/class-validator" target="blank">class-validator</a>, the amazing library which allows using decorator-based validation.
      Decorator based validation is really powerful with the <strong>pipe</strong> abilities since we have an access to the <code>metatype</code> of the processed property.
      Let's add few decorators to the <code>CreateCatDto</code>.
    </p>
    <span class="filename">create-cat.dto.ts</span>
    <pre><code class="language-typescript">{{ createCatDtoValidation }}</code></pre>
    <p>
      Now it's time to finish the <code>ValidationPipe</code> class.
    </p>
    <span class="filename">validation.pipe.ts</span>
   <pre><code class="language-typescript">{{ fullValidationPipe }}</code></pre>
   <blockquote>
      <strong>Notice</strong> I've used the <a href="https://github.com/pleerock/class-transformer">class-transformer</a> library. It's made by the same author as the <strong>class-validator</strong>, so they're playing well together.
   </blockquote>
   <p>
     Let's go through this code. Firstly, note that <code>transform()</code> function is <code>async</code>.
     It's possible because Nest supports both synchronous and <strong>asynchronous</strong> pipes.
     Also, there's a helper function - <code>toValidate()</code>. Its responsibility is to exclude the native JavaScript types from the validation process.
     The last important thing is that we have to return the same value. This pipe is a validation specific pipe, so we need to return the exact same property to avoid the <strong>overriding</strong>.   </p>
   <p>
     The last step is to setup the <code>ValidationPipe</code>. Pipes, same as <a routerLink="/exception-filters">exception filters</a> can be method-scoped, controller-scoped and global-scoped.
      Additionally, a pipe may be param-scoped. We can directly bind the pipe instance to the route param decorator, for example <code>@Body()</code>.
      Let's have a look at the below example:
   </p>
   <span class="filename">cats.controler.ts</span>
    <pre><code class="language-typescript">{{ createCatsControllerParamPipe }}</code></pre>
    <p>
      The param-scoped pipes are useful when the validation logic concerns only one, specified parameter.
      To setup pipe at a method level, you'll need the <code>UsePipes()</code> decorator.
    </p>
    <span class="filename">cats.controler.ts</span>
    <pre><code class="language-typescript">{{ createCatsControllerMethodPipe }}</code></pre>
    <blockquote>
      <strong>Notice</strong> The <code>@UsePipes()</code> decorator is imported from the <code>@nestjs/common</code> package.
   </blockquote>
    <p>
      Since the <code>ValidationPipe</code> was created to be as generic as possible, we're gonna setup it as a <strong>global-scoped</strong> pipe, for every route handler across the entire application.
    </p>
    <span class="filename">server.ts</span>
    <pre><code class="language-typescript">{{ globalPipe }}</code></pre>
    <blockquote>
      <strong>Notice</strong> The <code>useGlobalPipes()</code> method doesn't setup pipes for gateways and microservices.
    </blockquote>
    <h4>Transformer Pipe</h4>
    <p>
      Validation isn't the sole use case. At the beginning of this chapter, I've mentioned that pipe <strong>transforms</strong> the input data to the desired output.
      It's true because the value returned from the <code>transform</code> function completely overrides the previous value of the argument.
      Sometimes the data passed from the client needs to undergo some changes. Also, some parts could be missed, so we must apply the default values.
      The <strong>transformer pipes</strong> fill the gap between the client request and the request handler.
    </p>
    <span class="filename">
      {{ 'parse-int.pipe' | extension: parseIntPipeT.isJsActive }}
      <app-tabs #parseIntPipeT></app-tabs>
    </span>
    <pre [class.hide]="parseIntPipeT.isJsActive"><code class="language-typescript">{{ parseIntPipe }}</code></pre>
    <pre [class.hide]="!parseIntPipeT.isJsActive"><code class="language-typescript">{{ parseIntPipeJs }}</code></pre>
    <p>
      Here's a <code>ParseIntPipe</code> which resposibility is to parse string into integer value.
      Now let's bind the pipe to the selected param:
    </p>
    <span class="filename">
      <app-tabs #bindParamT></app-tabs>
    </span>
    <pre [class.hide]="bindParamT.isJsActive"><code class="language-typescript">{{ bindParam }}</code></pre>
    <pre [class.hide]="!bindParamT.isJsActive"><code class="language-typescript">{{ bindParamJs }}</code></pre>
    <h4>Built-in pipes</h4>
    <p>
      Fortunately, you don't have to build those pipes on your own since the <code>ValidationPipe</code> and the <code>ParseIntPipe</code> are built-in pipes.
    </p>
    <p>
      The built-in <code>ValidationPipe</code> offers more options than the one described above, which has been kept basic for the sake of simplicity and to reduce the learning curve.<br/>
      By default, this pipe doesn't mutate the payload value. However, you might want to get an actual <code>CreateCatDto</code> instance in your controller, and not just a plain javascript object.
      In order to achieve that, you can configure the pipe:
    </p>
    <span class="filename">cats.controler.ts</span>
    <pre><code class="language-typescript">{{ createCatsControllerParamPipeTransformTrue }}</code></pre>
    <p>
      Because this pipe is based on the <code>class-validator</code> and the <code>class-transformer</code> libraries, it is possible to get more of it.
      Have a look at the constructor optional options.
    </p>
    <pre><code class="language-typescript">{{ constructorCode }}</code></pre>
    <p>
      There is a <code>transform</code> attribute and all <code>class-validator</code> options (inherited from the <code>ValidatorOptions</code> interface):
    </p>
    <table>
      <tr>
        <th>Option</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
      <tr>
        <td><code>skipMissingProperties</code></td>
        <td><code>boolean</code></td>
        <td>If set to true than validator will skip validation of all properties that are missing in the validating object.</td>
      </tr>
      <tr>
        <td><code>whitelist</code></td>
        <td><code>boolean</code></td>
        <td>If set to true validator will strip validated object of any properties that do not have any decorators.</td>
      </tr>
      <tr>
        <td><code>forbidNonWhitelisted</code></td>
        <td><code>boolean</code></td>
        <td>If set to true, instead of stripping non-whitelisted properties validator will throw an error.</td>
      </tr>
      <tr>
        <td><code>groups</code></td>
        <td><code>string[]</code></td>
        <td>Groups to be used during validation of the object.</td>
      </tr>
      <tr>
        <td><code>dismissDefaultMessages</code></td>
        <td><code>boolean</code></td>
        <td>If set to true, the validation will not use default messages. Error message always will be undefined if its not explicitly set.</td>
      </tr>
      <tr>
        <td><code>validationError.target</code></td>
        <td><code>boolean</code></td>
        <td>Indicates if target should be exposed in ValidationError.</td>
      </tr>
      <tr>
        <td><code>validationError.value</code></td>
        <td><code>boolean</code></td>
        <td>Indicates if validated value should be exposed in ValidationError.</td>
      </tr>
    </table>
    <blockquote>
      <strong>Notice</strong> You might find more information about the <code>class-validator</code> in its <a href="https://github.com/typestack/class-validator">repository</a>.
    </blockquote>

</div>
